#!/usr/bin/env stack
-- stack --install-ghc runghc --package turtle

{-# LANGUAGE OverloadedStrings #-}

-- | sdb.hs - a standalone script to manage a local development postgres cluster.

-- Code notes:
--
-- * Original idea taken from https://git.gnu.io/snippets/3
-- * underscore_names are used for functions that mimic shell commands.
-- * I intentionally did not use Turtle.Options nor optparse-applicative.
--   The autogenerated help text is no good.

import Prelude hiding (FilePath)

import Control.Exception.Base (bracket)
import Data.Maybe (catMaybes)
import GHC.IO.Handle (hDuplicate, hDuplicateTo)
import System.Environment (getProgName, getArgs)
import System.IO (openFile, IOMode(..))
import System.Process (callProcess)
import Turtle
import qualified Control.Foldl as F
import qualified Data.Text as T
import qualified Filesystem.Path.CurrentOS as P
import qualified System.IO as H

pgWorkDir = ".postgres-work"

usageText = mapM_ err
    [ "sdb.hs: a wrapper to set up environment variables and run various"
    , "commands for your local postgres database for Snowdrift.coop"
    , "development."
    , ""
    , "Usage:"
    , ""
    , "    sdb.hs ACTION [ARGS]"
    , ""
    , "Where ACTION may be one of:"
    , ""
    , "    init              initialize the database cluster and databases"
    , "    start             start the cluster"
    , "    stop              stop  the cluster"
    , "    clean             \"rm -rf\" the whole cluster"
    , "    reset             re-init the cluster and databases"
    , "    export            create data dumps with pg_dump"
    , ""
    , "    # Expert commands:"
    , "    pg_ctl            run Postgres' pg_ctl(1) utility"
    , "    psql DATABASE     connect to DATABASE with psql"
    ]

main = sh $ do
    (root, pghost, pgdata) <- initEnv

    let init'  = initCluster root pghost pgdata
        clean' = rm_rf (root </> pgWorkDir)
        stop'  = void (proc "pg_ctl" ["stop"] empty)

    args <- liftIO getArgs
    case args of
        ["init"] -> init'
        ["start"] ->
            void (shell "pg_isready" empty .||. proc "pg_ctl" ["start"] empty)
        ["stop"] -> stop'
        ["clean"] -> stop' >> clean'
        ["reset"] -> stop' >> clean' >> init'
        ["export"] -> exportDb root
        ("pg_ctl":as') -> procs "pg_ctl" (map T.pack as') empty
        ("psql":as') -> liftIO $ callProcess "psql" as'
        ["--help"] -> usageText
        _ -> do
            err ""
            err "** Unknown or missing options! **"
            err ""
            usageText
            exit (ExitFailure 1)

exportDb :: FilePath -> Shell ()
exportDb root = do
    step "Dumping to devDB.sql..."
    output (root </> "dev" </> "devDB.sql") $ pgDump "snowdrift_development"
    step "Dumping to testDB.sql..."
    output (root </> "dev" </> "testDB.sql") $ pgDump "snowdrift_test_template"
  where
    pgDump db = inproc "pg_dump" ["--no-owner", "--no-privileges", "--create", db] empty

initCluster :: FilePath -> FilePath -> FilePath -> Shell ()
initCluster root pghost pgdata = do
    step "Creating directories..."
    mktree pghost
    mktree pgdata

    step "Initializing cluster..."
    hush $ procs "pg_ctl" ["initdb", "-o", "--nosync --auth=peer", "-D", pgdata'] empty

    step "Updating cluster configuration file..."
    setPgConfigOpts (pgdata </> "postgresql.conf")
        [ -- set the unix socket directory because pg_ctl start doesn't
          -- pay attention to PGHOST (wat.)
          ("unix_socket_directory", pghost')
        , ("unix_socket_directories", pghost')
        , ("archive_mode", "off")
        , ("fsync", "off")
        , ("wal_level", "minimal")
          -- don't bother listening on a port, just a socket.
        , ("listen_addresses", "''")
        ]

    step "Starting database server..."
    procs "pg_ctl" ["start", "-w"] empty

    step "Creating and populating databases..."
    psql ["postgres"] $ input (root </> "dev" </> "devDB.sql")
    psql ["postgres"] $ input (root </> "dev" </> "testDB.sql")
    psql ["postgres"] $ select
        [ "update pg_database set datistemplate=true where datname='snowdrift_test_template';"
        ]

    step "Writing old-skool config file..."
    Just user <- need "USER"
    output "config/postgresql.yml" $ select (dbConfigTemplate user pghost')

    step "Success."

  where

    pghost'  = "'" <> toText_ pghost <> "'"
    logfile  = root </> "init-dev-db.log"
    logfile' = toText_ logfile
    pgdata'  = toText_ pgdata
    setPgConfigOpts f opts =
        inplace_ (choice (patterns opts)) f
    patterns opts =
        map (fmap Just . uncurry optSettingPattern) opts
        <> [ commentOrEmpty >> pure Nothing ]
    commentOrEmpty :: Pattern Text
    commentOrEmpty =
        contains (begins spaces >> (T.singleton <$> (char '#' <|> newline)))
    optSettingPattern opt value = do
        -- match the line with the option
        _ <- contains $ do
            begins (star (oneOf " #"))
            text opt
            once (oneOf " =")
        -- replace it with 'opt = value'
        return (opt <> " = " <> value)

-- | Template for database config file.
dbConfigTemplate user pghost =
    [ "Default: &defaults"
    , format ("   user: "%s) user
    , "   password: \"\""
    , format ("   host: "%s) pghost
    , "   database: snowdrift_development"
    , "   poolsize: 10"
    , ""
    , "Development:"
    , "  <<: *defaults"
    , ""
    , "Testing:"
    , "  database: snowdrift_test"
    , "  <<: *defaults"
    , ""
    , "Staging:"
    , "  database: snowdrift_staging"
    , "  poolsize: 100"
    , "  <<: *defaults"
    , ""
    , "Production:"
    , "  <<: *defaults"
    ]

-- | Print a header for a step
step s = err ("## " <> s)

-- | Create and export some env variables
initEnv :: Shell (FilePath, FilePath, FilePath)
initEnv = do
    root <- getProjectRoot
    Just path <- need "PATH"
    pgPath <- inshell "pg_config --bindir" ""

    let pghost = root </> pgWorkDir </> "sockets"
        pgdata = root </> pgWorkDir </> "data"
    export "PGHOST" (toText_ pghost)
    export "PGDATA" (toText_ pgdata)
    export "PATH" (format (s%":"%s) path pgPath)
    return (root, pghost, pgdata)
  where
    getProjectRoot =
        realpath =<< (directory . P.decodeString <$> liftIO getProgName)


-- | A fail-early version of psql
psql args = hush . procs "psql" (["-q", "-v", "ON_ERROR_STOP="] <> args)

-- ##
-- ## Helper functions/additions to underlying libs
-- ##

-- | Seeing as I use this everywhere
toText_ :: FilePath -> Text
toText_ = format fp

-- | inplace with filtering.
inplace_ :: MonadIO io => Pattern (Maybe Text) -> FilePath -> io ()
inplace_ pat file = liftIO (runManaged (do
    here              <- pwd
    (tmpfile, handle) <- mktemp here "turtle"
    outhandle handle (sed_ pat (input file))
    liftIO (H.hClose handle)
    mv tmpfile file ))

-- | sed with filtering.
sed_ :: Pattern (Maybe Text) -> Shell Text -> Shell Text
sed_ pat s = flatten $ do
    when (matchesEmpty pat) (die message)
    let pat' = fmap mconcat
            (many (pat <|> fmap (Just . T.singleton) anyChar))
    txt    <- s
    txt':_ <- return (match pat' txt)
    return txt'
  where
    message = "sed: the given pattern matches the empty string"
    matchesEmpty = not . null . flip match ""
    flatten s = do
        Just x <- s
        return x

-- | Run a shell and send stdout/stderr to nowhere
hush :: Shell () -> Shell ()
hush s = liftIO $ bracket
    (do
        saveErr <- hDuplicate H.stderr
        saveOut <- hDuplicate H.stdout
        h <- openFile "/dev/null" WriteMode
        hDuplicateTo h H.stderr
        hDuplicateTo h H.stdout
        return (saveErr, saveOut)
    )
    (\(saveErr, saveOut) -> do
        hDuplicateTo saveErr H.stderr
        hDuplicateTo saveOut H.stdout)
    (const (sh s))

-- | rm -rf a directory. thx.
rm_rf dir = do
    True <- testdir dir
    rmtree dir
